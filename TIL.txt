Unchecked runtime.lastError: 
A listener indicated an asynchronous response by returning true, 
but the message channel closed before a response was received


깨달음
1. 이벤트에는 연속적/반복적인 것이 있고 불연속적인 것이 있다.
: 따라서, 전자에는 Local Getter, 변수 설정 등의 동적인 핸들링을, 
: 후자에는 classToggle, mediaQuery 등의 정적인 핸들링을 해줘야한다.

2. 공통 이벤트 핸들링
: 이벤트 전이와 HTML data를 이용하는게 유리하다.

3. 콜백함수 안에 할 일이 너무 많다면 함수를 지정해서 파트별로 분류해준다.

-------------------------------------------------------------------------------------

# BoxHeight을 가져오기
header.offsetHeight
header.getBoundingClientRect().height
: 성능적으로도 기능적으로도 offsetHeight보다 우월함

# 스크롤 위치를 인식하여 애니메이션 추가하기 (연속적 속성 정의)
classList 토글은 정적이라 연속적인 애니메이션을 핸들링하기 어렵다.
따라서, opacity (style) 자체를 변수로 정의한다.
opacity = 1 - window.scrollY  / home.getBoundingClientRect().height 로 하면 두 값이 같아질 때 0이 된다.
이제, opacity를 home에 set한다.
## 문제: opacity < 0 부터의 계산은 불필요하다.
## 해결: Math.max(opacity, 0) 처리를 해준다.

# 반응형 탭 만들기
1) icon width에 따라 반응형 보이기 (mediaQuery)
2) icon 토글; display: none (visibility는 레이아웃을 변경함)
3) scroll 이동이 감지되면 clicked 클래스 없애기 (로컬 getter)
전역으로 정의된 getter는 해당 함수가 호출된 시점의 상태를 반환하므로,
한 번 호출된 후에는 반환 값이 고정되어 이후에 상태가 변경되어도 반영되지 않는다.
반면, 로컬로 정의된 getter는 호출될 때마다 항상 최신 상태를 가져와 반환하므로, 
동적인 상태를 잘 반영한다.

# MyWork Grid 필터링
클릭이벤트 -> 토글 기능을 넣으면 될듯
버튼 클릭 -> 해당 클래스를 제외하고 display: none , visibility: hidden (부정선택자 :not())
.project > :not(.front-end) -> 자바스크립트 조건문으로 표현하고싶다..!!
project 각각에 대하여 (forEach), fe 클래스를 포함하지 않는다면 (contains), visibility: hidden
문제: visibility: hidden이 누적됨. fe를 클릭했으면 fe만 보이고, be를 클릭했으면 be만 보여야되잖아.
해결: else 문에서 visibility: visible을 전체적으로 추가

문제: 그리드 아이템이 좌상단에 정렬되지 않음
해결: gridRow, gridColumn을 수정하면 제어 (..?)
문제: visibility를 적용하면 이전 템플릿이 보여짐
해결: display: block, none을 사용

## 솔루션
1. 버튼에 data type을 지정하여 필터링
2. 이벤트 전이를 이용하여 catergories에 이벤트 리스너 달기
: 모든 자식요소에 Click 이벤트를 남발하는 것을 방지하기 위함
3. 버튼과 이미지의 dataset을 일치시키기
4. display: none으로 추가/제거
5. 핸들러에 anim-out 클래스를 추가/제거함으로써 트랜지션 효과 

# Intersection Observer
-> const observer = new IntersectionObserver (callback, option)

<1> observer
: IntersectionObserver 인스턴스; 관찰을 중단하거나 시작
: observer.observe( 감시할 Node )


<2> callback
A. entries
: IntersectionObserverEntry 객체의 배열
: 각 entry는 하나의 관찰된 요소에 대한 정보를 담고 있는 객체

B. entry 객체 정보
entry.target: 관찰된 요소를 나타내는 DOM 요소
entry.intersectionRatio: 관찰된 요소가 intersect하는 비율; 0에서 1 사이의 값
entry.isIntersecting: 관찰된 요소가 현재 intersect하는지 여부를 나타내는 불리언 값

<3> option = {
  A. threshold
  : isIntersecting을 판단할 intersectionRatio 기준을 지정 (기본값 0 )
  : Intersect를 판단할 지점을 배열로 지정 
  ex. [0, 0.5. 0.8]
  : target의 0%, 50%, 80% 만큼 intersect 될 때마다 callback을 호출

  B. rootMargin: Intersect Container의 크기를 확대/축소
  C. root: Intersect Container를 지정 (기본값: null (뷰포트))
}






